# SPLIT Stack Technical Documentation

## Core Architecture

### Domain-Driven Organization

SPLIT Stack encourages organizing code by domain (entity/model) rather than technical layers. This approach:

- Makes related code easier to find and maintain
- Reduces cognitive load when working on features
- Facilitates better separation of concerns
- Makes the codebase more scalable

### Type Generation Pipeline

```
Database Schema â†’ Laravel Models â†’ TypeScript Interfaces â†’ Frontend Components
```

The type generation system ensures:

1. Database columns are reflected in Laravel model properties
2. Laravel models are automatically converted to TypeScript interfaces
3. Form validation matches TypeScript types
4. API responses are fully typed
5. Route parameters are type-checked

## Context-Aware Components

### The Strategy Pattern Implementation

The **context system** uses the **strategy pattern** to handle different behaviors based on user roles.

For each "domain" (e.g. `Projects`) we define **contexts** that you can decide to make wide or narrow down
to a specific type of view (e.g. tables or datalists).

Each context will **need** to provide a `getStrategyForRole` method, but the implementation details are up to you (ususally a `switch` statement or a `map`).

Each strategy will then define things like the kind of data to display (e.g. headers and action buttons of a table, or the data of a datalist).

Code example (full,non-simplified!):

1. **Context Definition**

```typescript
import { Context } from '$lib/core/contexts/context';
import { BaseDataDisplayStrategy } from '$lib/core/strategies/dataDisplayStrategy';
import { Project } from '$models';

export class ProjectContext implements Context<Project> {
  // Context class is a generic Interface defined by the SPLIT Stack
  strategy: BaseDataDisplayStrategy<Project>;

  constructor(role: string) {
    this.strategy = this.getStrategyForRole(role);
  }

  // This method is required by the Context interface
  getStrategyForRole(role: string): BaseDataDisplayStrategy<Project> {
    switch (role) {
      case 'admin':
        return new AdminProjectTableStrategy();
      case 'freelancer':
        return new FreelancerProjectDataDisplayStrategy();
      case 'employer':
        return new EmployerProjectDataDisplayStrategy();
      default:
        return new DefaultProjectTableStrategy();
    }
  }
}
```

2. **Strategy Implementation**

```typescript
import type {
  DataAction,
  DataHeader,
  IDataStrategy,
} from '$types/common/dataDisplay';
import { BaseDataDisplayStrategy } from '$lib/core/strategies/dataDisplayStrategy';
import { Project } from '$models';

export class FreelancerProjectTableStrategy
  extends BaseDataDisplayStrategy<Project>
  // BaseDataDisplayStrategy is a generic class defined by the SPLIT Stack
  implements IDataStrategy<Project>
{
  // IDataStrategy is a generic Interface defined by the SPLIT Stack
  /**
   * @abstract You must implement this method
   **/
  defaultHeaders(): DataHeader<Project>[] {
    return [
      { key: 'name', label: 'Name', searchable: true },
      { key: 'description', label: 'Description', searchable: true },
      { key: 'organization.name', label: 'Organization', searchable: true },
    ];
  }

  /**
   * @abstract You must implement this method
   **/
  defaultActions(): DataAction<Project>[] {
    return [
      {
        label: 'Edit',
        href: (row: Project) => route('project.edit', row.id),
      },
      {
        label: 'Delete',
        callback: Project.delete,
        css: () => 'text-red-500',
        icon: () => Trash2,
      },
    ];
  }
}
```

3. **Usage in Components**

```typescript
<script lang="ts">
  import { RoleContext } from '$lib/stores/global/roleContext.svelte'; // ðŸ”‹ included in SPLIT Stack
  import { ProjectContext } from '$lib/domains/Project/context'; // Defined by you, but scaffolded by the split:domain command
  import type { Project } from '$models'; // Can be generated by the split:modelgen command

  interface Props {
    projects: Project[];
  }

  let { projects }: Props = $props();
  let context = $derived(new ProjectContext(RoleContext.selected));
  let headers = $derived(context.strategy.headers());
  let actions = $derived(context.strategy.actions());
</script>

<DataTable {headers} {actions} data={projects} />
```

## Navigation System

### Role-Based Navigation

Navigation is handled through strategies similar to context-aware components:

```typescript
export class AdminNavigationStrategy implements NavigationStrategy {
  // NavigationStrategy is a generic Interface defined by the SPLIT Stack
  getNavigationItems(): NavigationItem[] {
    return [
      {
        label: 'Dashboard',
        href: route('dashboard'),
        icon: Home,
      },
      {
        label: 'Projects',
        href: route('projects.index'),
        icon: Briefcase,
        children: [
          {
            label: 'All Projects',
            href: route('projects.index'),
          },
          {
            label: 'Archived',
            href: route('projects.archived'),
          },
        ],
      },
    ];
  }
}
```

## Toast Notification System

### Backend Integration

The toast system automatically captures Laravel flash messages:

```php
// In your controller
return redirect()->back()->with('success', 'Project created!');
```

### Frontend Usage

Direct toast triggering from components:

```typescript
import { toaster } from '$lib/stores/global/toaster.svelte'; // ðŸ”‹ included in SPLIT Stack

// Basic usage
toaster.success('Operation completed!');

// With Inertia form
const form = superUseForm();

function handleSubmit() {
  $form.post(route('project.store'), {
    onSuccess: () => {
      toaster.success('Project created successfully');
    },
    onError: () => {
      toaster.error('Failed to create project');
    },
  });
}
```

### Toast Configuration

Toasts can be customized globally:

```typescript
// $lib/config/toast.ts
export const DEFAULT_TOAST_OPTIONS: ToastOptions = {
  color: 'purple',
  duration: 3000,
  position: 'top-right',
};
```

## Form Handling

### Type-Safe Forms

Forms are automatically typed based on your Laravel models:

```typescript
// This type can be generated by the split:modelgen command
interface ProjectForm {
  name: string;
  description: string;
  due_date: Date;
  organization_id: number;
}

const form = superUseForm<ProjectForm>();
```

### Validation Integration

Laravel validation rules are automatically mapped to frontend validation:

```php
// Backend validation
public function rules(): array
{
    return [
        'name' => ['required', 'string', 'max:255'],
        'description' => ['required', 'string'],
        'due_date' => ['required', 'date'],
        'organization_id' => ['required', 'exists:organizations,id']
    ];
}
```

```typescript
// Frontend receives typed validation errors
function handleSubmit() {
  $form.post(route('project.store'), {
    onError: (errors) => {
      // errors is typed based on ProjectForm
      console.log(errors.name); // string | undefined
    },
  });
}
```

## Repository Caching

SPLIT stack includes an attribute-based caching system for repositories. This allows you to easily cache repository method results with minimal boilerplate.

### Usage

Generate a new cached repository:

```bash
php artisan split:repo User --ttl=300  # TTL in seconds (default: 60)
```

This generates a repository with built-in caching:

```php
class UserRepository {
    use CacheableRepo;

    #[WithCache('users.all', 300)]
    public static function index() {
        return User::all();
    }

    #[WithCache('users.{id}', 300)]
    public static function find($id) {
        return User::find($id);
    }
}
```

Access your repository methods with caching:

```php
// Get cached data (creates cache if doesn't exist)
$users = UserRepository::cached('index');

// Get fresh data without touching cache
$freshUsers = UserRepository::fresh('find', id: 1);

// Invalidate cache and get fresh data
$updatedUsers = UserRepository::refresh('index');
```

### Cache Configuration

The `WithCache` attribute accepts these parameters:

- `key`: Cache key (supports parameter interpolation with `{paramName}`)
- `ttl`: Time-to-live in seconds
- `useQuery`: Include query parameters in cache key
- `tags`: Array of cache tags for grouped invalidation

Example with all options:

```php
#[WithCache(
    key: 'users.active.{status}',
    ttl: 300,
    useQuery: true,
    tags: ['users', 'active']
)]
public static function getActive($status) {
    return User::where('status', $status)->get();
}
```

### Cache Keys

Cache keys support parameter interpolation:

- Sequential parameters: `users.{0}`, e.g. `find($value)`
- Named parameters: `users.search.{name}.{age}` e.g. `search(age: 30, name: 'John')`
- Query parameters: Appended automatically when `useQuery: true`

### Sequential Parameters

When your method uses regular parameters, the values are matched by position:

```php
#[WithCache('products.category.{catId}.page.{pageNumber}')] //the name between {} is up to you unless you use named parameters
public static function getByCategory($categoryId, $page) {
    return Product::where('category_id', $categoryId)
        ->paginate($page);
}

// Usage:
ProductRepository::cached('getByCategory', 5, 1);
// Creates cache key: "products.category.5.page.1"
```

### Named Parameters

When passing an associative array or named parameters, parameters are matched by name,

and **order does not matter** anymore.

```php
#[WithCache('orders.status.{status}.user.{userId}')]
public static function getUserOrders($params) {
    return Order::where('user_id', $params['userId'])
        ->where('status', $params['status'])
        ->get();
}

#[WithCache('orders.search.{status}.user.{userId}')] 
public static function search($userId, $status) {
    return Order::where('user_id', $userId)
        ->where('status', $status)
        ->get();
}

// Usage:
ProductRepository::cached('getUserOrders', [
    'userId' => 123,
    'status' => 'pending'
]);
// Creates cache key: "orders.status.pending.user.123"

ProductRepository::cached('search', status: 'pending', userId: 123);
// Same cache key: "orders.search.pending.user.123"
```

The key difference is how you pass the parameters when calling `cached()`. 

### Query appending

When `useQuery` is set to `true`, query parameters are automatically appended to the cache key:

```php
#[WithCache('products.category.{catId}', ttl: 300, useQuery: true)]
public static function search() {
    $searchParams = request()->query();
    $query = Product::where('category_id', $query['catId'])
        ->where('name', 'like', "%{$query['name']}%");
    if($query['price']) {
        $query->where('price', '>', $query['price']);
    }
    return $query->get();
}
// Cache key: "products.category.5?name=apple&price=100"
```

Use whichever style makes more sense for your use case - sequential for simple parameters, named for clearer intent with multiple parameters.


## CLI Tools

### Domain Generation

Generate a new domain with role-based contexts:

```bash
php artisan split:domain Project admin freelancer employer
```

This creates:

- ProjectContext class
- Role-specific strategies
- Default strategy
- Basic tests

### Navigation Generation

Create role-specific navigation:

```bash
php artisan split:navigation admin freelancer employer
```

Generates:

- Navigation strategies for each role
- Navigation store
- Navigation components

## Various JS/TS utilities

### Array Utilities

The `arrays.ts` utility provides helpful functions for array manipulation:

- `groupBy<T>(arr: Record<string,T>[], key: string)`: Groups array of objects by a key (supports nested keys via dot notation)
- `unique(arr: any[])`: Returns new array with only unique elements
- `mapUnique(arr: any[], callback)`: Maps array through callback and returns unique results

### Object utilities

- `dot(obj: any, key: string)`: Resolves a nested value from an object using dot notation

### Formatting utilities

- `currency(value: number, locale: string)`: Formats a number as a currency string
- `asSelectOptions(data: any[], valueColumn: string, nameColumn: string)`: Formats an array of objects as an array of select options
- `time(date: Date, format: string)`: Formats a time using a specified format
- `date(date: Date, format: string)`: Formats a date using a specified format
- `datetime(date: Date, format: string)`: Formats a date and time using a specified format

Centralize your date formatting in one place with the default constants.

Formats:

```typescript
// Feel free to change these to your liking
export const DATE_FORMAT = 'YYYY/MM/DD';
export const TIME_FORMAT = 'HH:mm';
export const DATETIME_FORMAT = `${DATE_FORMAT} ${TIME_FORMAT}`;

// Usage
time(new Date(), 'h:mm a'); // '12:00 PM'
date(new Date(), 'MM/dd/yyyy'); // '01/24/2025'
datetime(new Date(), 'MM/dd/yyyy h:mm a'); // '01/24/2025 12:00 PM'
```

### String Utilities

The `strings.ts` utility provides helpful functions for string manipulation:

- `capitalize(str: string)`: Capitalizes the first letter of a string
- `camelCase(str: string)`: Converts a string to camel case
- `kebabCase(str: string)`: Converts a string to kebab case
- `snakeCase(str: string)`: Converts a string to snake case
- `slugify(str: string)`: Converts a string to a slug

### Markup highlighting

The `highlight.ts` utility provides a utility `class` that can be used to highlight text in a string.

Great when working with search results!

### Core Methods (static)

#### Matching Methods

- `Fuzzy(target, searchQuery)`: Performs fuzzy matching on objects or string arrays
- `Exact(candidate, searchQuery)`: Performs exact matching on specific object fields
- `IgnoreCase(candidate, searchQuery)`: Case-insensitive matching on object fields

#### Highlighting Methods

- `highlight(targetString, searchString, highlightClass?, type?)`: Generic highlighting with support for both fuzzy and exact matching
- `highlightMany(targetString, searchStrings, highlightClasses, type?)`: Highlights multiple strings with different styles
- `fuzzyHighlight(targetString, searchString, highlightClass?)`: Highlights individual matching characters
- `exactHighlight(targetString, searchString, highlightClass?)`: Highlights exact matches

### Usage Examples

```typescript
const highlighted = Highlighter.highlight(
  target,
  searchQuery,
  'highlight-class',
  'fuzzy'
);

// Highlighting multiple strings
const highlightedMany = Highlighter.highlightMany(
  target,
  searchQueries,
  ['highlight-class-1', 'highlight-class-2'],
  'exact'
);

// Fuzzy highlighting
const fuzzyHighlighted = Highlighter.fuzzyHighlight(
  target,
  searchQuery,
  'highlight-class'
);

// Exact highlighting
const exactHighlighted = Highlighter.exactHighlight(
  target,
  searchQuery,
  'highlight-class'
);
```

### Request Utilities

- `debounce(fn: () => any, wait: number)`: Creates a debounced version of a function

### Assessing Utilities

- `truthy(value: any)`: Checks if a value is truthy (**strictly** not undefined or null or false)
- `falsy(value: any)`: Just a ! of the value. Mostly for readability purposes.
- `empty(value: any)`: Checks if a value is empty (undefined, null, '', [], {})
- `exists(value: any)`: Checks if a value exists (not empty)

Example usage:

```typescript
exists(null); // false
exists(''); // false
exists([]); // false
exists({}); // false
exists(1); // true
exists('hello'); // true

empty(null); // true
empty(''); // true
empty([]); // true
empty({}); // true
empty(1); // false
empty('hello'); // false

truthy(null); // false
truthy(''); // false
truthy([]); // false
truthy({}); // false
truthy(1); // true
truthy('hello'); // true

falsy(null); // true
falsy(''); // true
falsy([]); // true
falsy({}); // true
falsy(1); // false
falsy('hello'); // false
```
